<h1 id = "Debugging_Your_Bot">Debugging Your Bot</h1>

<h2 id = "Approaches">Approaches</h2>

<p>One important area was omitted from the tutorial so far: how do you debug your bot code?
There are multiple options. Which one is best depends on your goals and your development
environment. Here are the three main approaches:</p>

<ul>
<li><p><strong>Using the Scalatron IDE for browser-based development</strong>: since compilation and execution
occur on the server computer (to which you may not have any other access) and the IDE is
fairly basic, there is no way to debug the code by setting break-points ot single-stepping
through it. You can, however, single-step through the simulation and inspect the input and
state of your entities (bots and mini-bots), as well as have your bot output debug
information.</p></li>
<li><p><strong>Using IntelliJ IDEA with a local test server</strong>: if you are using IDEA to build your
bots (the same may also be true for the Scala IDE), you can install and run a local test
server, have it load your plug-in and then debug with breakpoints and single-stepping
within the IDE. This approach is probably the most powerful. It is recommended for
serious enthusiasts that want to build really clever and complex bots. For more information,
see the chapter on debugging with IDEA in the <em>Player Setup</em> guide.</p></li>
<li><p><strong>Using local builds with a central tournament server</strong>: the only option for debugging
in this scenario is to use server-side logging into a user-specific directory.</p></li>
</ul>

<p>Some of these options will be elaborated on in the next few bot examples of the tutorial.</p>

<h2 id = "Making_State_Visible">Making State Visible</h2>

<p>The debugging approach with longest history is also the simplest: use outputs generated by
your program to trace its behavior at points of interest and to narrow the location of
aberrations. The Scalatron protocol provides several mechanisms for doing this:</p>

<ul>
<li><p><strong>Status()</strong> &mdash; using the <code>Status</code> opcode, a bot or mini-bot can display a short message
above its location on the tournament screen. This can be used to indicate some aspects of
the state of the bot in a way that is visible while it is running in a multi-player
tournament round. You can, for example, display messages like &ldquo;Searching&hellip;&rdquo; while the bot
is scouting for food, &ldquo;Approaching&hellip;&rdquo; while it is closing in on a food item, etc.</p></li>
<li><p><strong>Say()</strong> &mdash; using the <code>Say</code> opcode, a bot or mini-bot can leave a textual &ldquo;bread-crumb&rdquo; at
its current location on the screen. The bread-crumb will stay in its initial location even
when the bot moves away and will gradually fade away over the course of a few seconds.
<code>Say</code> is thus a good way to generate records of events or state changes (as opposed to states
themselves). They remain visible even as the simulation moves on. Examples include messages
like &ldquo;Spotted Food&rdquo;, &ldquo;Proximity Fuse&rdquo; or &ldquo;Fighting&rarr;Harvesting&rdquo;.</p></li>
<li><p><strong>Log()</strong> &mdash; using the <code>Log</code> opcode, a bot or mini-bot can record a multi-line debug message
in its entity state. This debug message can be inspected in the browser-based Scalatron IDE
while running in a sandbox. You can essentially record whatever you want, with the unfortunate
limitation that the server's relatively dumb parser must not be confused by it. So certain
characters are not permitted: comma (<code>,</code>), equals sign (<code>=</code>), parentheses (<code>(</code>, <code>)</code>),
pipe (<code>|</code>).</p></li>
<li><p><strong>Set()</strong> &mdash; using the <code>Set</code> opcode, a bot or mini-bot can record key/value pairs into the
state parameters which the server maintains for it. These state parameters can be inspected
in the browser-based Scalatron IDE while single-stepping through a sandboxed simulation.</p></li>
<li><p><strong>Displaying a window</strong> &mdash; open a window (e.g. using an AWT Frame) and render some debug
information in real-time. This makes sense only if your code uses complex data structures that
would be too cumbersome to analyze in a log file. Note also that while you can, of course, do
this on a locally running test game server at any time, on the shared game server whose display
is projected for everyone to see this is pretty intrusive.</p></li>
<li><p><strong>Logging to disk</strong> &mdash; in the <code>Welcome</code> message sent by the server, record the path to the
directory in which your bot plug-in resides <em>as seen by the server</em>. Then add debug logging
instructions to your code that make the state of your program visible at critical points by
writing into a log file in that directory. This technique is explained in detail soon via a
bot example.</p></li>
</ul>

<h2 id = "Example_Bot:_Debug_Logger">Example Bot: Debug Logger</h2>

<h1 id = "Bot__11:_Handler_Methods">Bot #11: Handler Methods</h1>

<h2 id = "Objective">Objective</h2>

<p>In the bot examples shown so far, we’ve gradually introduced command parsing and expanded the
functionality of the bots. It is now time to make the bot structure a bit more elegant. We will
do this in several steps, spread out over multiple example bots. The first step will be to break
the control function up into handlers for the various opcodes sent by the server.</p>

<h2 id = "Source_Code">Source Code</h2>

<pre><code>// omitted: class ControlFunctionFactory
// omitted: class CommandParser
// omitted: class View

class ControlFunction() {
    // this method is called by the server
    def respond(input: String): String = {
        val (opcode, params) = CommandParser(input)
        opcode match {
            case "Welcome" =&gt;
                welcome(
                    params("name"),
                    params("path"),
                    params("apocalypse").toInt,
                    params("round").toInt
                )
            case "React" =&gt;
                react(
                    params("generation").toInt,
                    View(params("view")),
                    params
                )
            case "Goodbye" =&gt;
                goodbye(
                    params("energy").toInt
                )
            case _ =&gt;
                "" // OK
        }
    }

    def welcome(name: String, path: String, apocalypse: Int, round: Int) = ""

    def react(generation: Int, view: View, params: Map[String, String]) =
        if( generation == 0 ) reactAsMaster(view, params)
        else reactAsSlave(view, params)

    def goodbye(energy: Int) = ""

    def reactAsMaster(view: View, params: Map[String, String]) = "Status(text=Master)"

    def reactAsSlave(view: View, params: Map[String, String]) = "Status(text=Slave)"
}</code></pre>

<h2 id = "What_is_going_on_">What is going on?</h2>

<p>The changes are quite staright-forward and not Scala-specific, which is why we won't spend
a lot of time on them. Instead of handling the invocations from the server inside the
<code>respond()</code> method, we parse the command and feed it through a <code>match</code>/ <code>case</code>
pattern matcher. The pattern matcher contains one handler for each of the opcodes the
server may send (we ignore unknown opcodes).</p>

<p>Each handler extracts frequently-used parameters from the parsed parameter maps and
feeds them as arguments to an opcode-specific handler method:</p>

<ul>
<li>the <code>welcome()</code> method handles the <code>Welcome</code> opcode</li>
<li>the <code>react()</code> method handles the <code>React</code> opcode</li>
<li>the <code>goodbye()</code> method handles the <code>Goodbye</code> opcode</li>
</ul>

<p>Within the <code>react()</code> handler method we inspect the entity for which a response is
required and then branch into the appropriate entity-specific handler:</p>

<ul>
<li>the <code>reactAsMaster()</code> method handles <code>React</code> invocations for the (master) bot</li>
<li>the <code>reactAsSlave()</code> method handles <code>React</code> invocations for mini-bots</li>
</ul>

<p>When you build and publish this bot, you will see that the master bot displays a little
status text bubble saying &ldquo;Master&rdquo; next to it.</p>