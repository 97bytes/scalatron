<h1 id = "Bot__12:_Handler_Object">Bot #12: Handler Object</h1>

<h2 id = "Objective">Objective</h2>

<p>In preceding bot versions we occasionally held some state inside the Bot object, which contained
our control function.</p>

<h2 id = "Source_Code_v2">Source Code v2</h2>

<pre><code>// omitted: class ControlFunctionFactory
// omitted: class CommandParser
// omitted: class View

class ControlFunction() {
    // this method is called by the server
    def respond(input: String): String = {
        val (opcode, params) = CommandParser(input)
        opcode match {
            case "Welcome" =&gt;
                welcome(
                    params("name"),
                    params("path"),
                    params("apocalypse").toInt,
                    params("round").toInt
                )
            case "React" =&gt;
                react(
                    View(params("view")),
                    params("entity"),
                    params
                )
            case "Goodbye" =&gt;
                goodbye(
                    params("energy").toInt
                )
            case _ =&gt;
                "" // OK
        }
    }

    def welcome(name: String, path: String, apocalypse: Int, round: Int) = ""

    def react(view: View, entity: String, params: Map[String, String]) =
        if( entity == "Master" ) reactAsMaster(view, params)
        else reactAsSlave(view, params)

    def goodbye(energy: Int) = ""

    def reactAsMaster(view: View, params: Map[String, String]) = ""

    def reactAsSlave(view: View, params: Map[String, String]) = ""
}</code></pre>

<h2 id = "What_is_going_on_">What is going on?</h2>

<p>The setup is quite staright-forward: instead of handling the invocations from the server
inside the <code>respond()</code> method, we parse the command and feed it through a <code>match</code>/ <code>case</code>
pattern matcher. The pattern matcher contains one handler for each of the opcodes the
server may send (we ignore unknown opcodes).</p>

<p>Each handler extracts frequently-used parameters from the parsed parameter maps and
feeds them as arguments to an opcode-specific handler method:</p>

<ul>
<li>the <code>welcome()</code> method handles the <code>Welcome</code> opcode</li>
<li>the <code>react()</code> method handles the <code>React</code> opcode</li>
<li>the <code>goodbye()</code> method handles the <code>Goodbye</code> opcode</li>
</ul>

<p>Within the <code>react()</code> handler method we inspect the entity for which a response is
required and then branch into the appropriate entity-specific handler:</p>

<ul>
<li>the <code>reactAsMaster()</code> method handles <code>React</code> invocations for the (master) bot</li>
<li>the <code>reactAsSlave()</code> method handles <code>React</code> invocations for mini-bots</li>
</ul>